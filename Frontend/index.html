<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CityBuilder 3000 website</title>

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: #fff;
      color: #111;
      display: flex;
      justify-content: center;
      padding: 48px 16px;
    }
    .page {
      max-width: 900px;
      width: 100%;
    }
    .header-row {
      display: flex;
      align-items: center;
      gap: 18px;
    }
    h1 {
      margin: 0;
      font-size: 2.25rem;
    }

    /* canvas size next to the title */
    #catCanvas {
      width: 96px;
      height: 96px;
      flex: 0 0 96px;
      border-radius: 10px;
      background: transparent;
      display: block;
    }

    p { line-height: 1.55; margin-top: 18px; font-size: 1rem; }
    strong { color: #0b72d0; }
    /* hover speeds wag */
    #catCanvas:hover { cursor: pointer; opacity: 0.98; }
  </style>
</head>
<body>
  <main class="page" role="main">
    <header class="header-row">
      <h1>salut les copains</h1>
      <!-- WebGL canvas for the animated cat -->
      <canvas id="catCanvas" width="192" height="192" aria-hidden="true" title="Animated cat (WebGL)"></canvas>
    </header>

    <p>This is the landing page of <strong>piscineVal1</strong>. The cat to the right is drawn with WebGL and animated (hover to speed the tail).</p>
  </main>
  <script>
    // ---- WebGL animated cat ----
  const canvas = document.getElementById('catCanvas');
  const gl = canvas.getContext('webgl', { antialias: true });
  if (!gl) {
    alert('WebGL not supported in this browser.');
    throw new Error('WebGL not supported');
  }

  // ---------------- shaders ----------------
  const vsSrc = `
    attribute vec2 a_pos;
    attribute vec3 a_color;
    uniform mat3 u_transform; // 2D transform matrix
    varying vec3 v_color;
    void main() {
      vec3 p = u_transform * vec3(a_pos, 1.0);
      gl_Position = vec4(p.xy, 0.0, 1.0);
      v_color = a_color;
    }
  `;

  const fsSrc = `
    precision mediump float;
    varying vec3 v_color;
    void main() {
      gl_FragColor = vec4(v_color, 1.0);
    }
  `;

  function createShader(type, source){
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }

  function createProgram(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(p));
      return null;
    }
    return p;
  }

  const vs = createShader(gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl.FRAGMENT_SHADER, fsSrc);
  const program = createProgram(vs, fs);
  gl.useProgram(program);

  // attributes & uniforms
  const aPosLoc = gl.getAttribLocation(program, 'a_pos');
  const aColorLoc = gl.getAttribLocation(program, 'a_color');
  const uTransformLoc = gl.getUniformLocation(program, 'u_transform');

  // buffer reused for drawing parts
  const vbo = gl.createBuffer();

  // ---------- small 2D mat3 helpers ----------
  const Mat3 = {
    identity() { return [1,0,0, 0,1,0, 0,0,1]; },
    multiply(a,b) {
      const out = [];
      for (let row=0; row<3; row++){
        for (let col=0; col<3; col++){
          let sum = 0;
          for (let k=0; k<3; k++){
            sum += a[row*3 + k] * b[k*3 + col];
          }
          out[row*3 + col] = sum;
        }
      }
      return out;
    },
    translation(tx,ty){
      return [1,0,0, 0,1,0, tx,ty,1];
    },
    rotation(rad){
      const c = Math.cos(rad), s = Math.sin(rad);
      return [c,-s,0, s,c,0, 0,0,1];
    },
    scale(sx,sy){
      return [sx,0,0, 0,sy,0, 0,0,1];
    }
  };

  // ---------- utility to draw a colored shape ----------
  // vertices: Float32Array of [x,y,r,g,b,...]
  // mode: gl.TRIANGLE_FAN / gl.TRIANGLES / etc
  // transform: mat3 array
  function drawShape(vertices, mode, transform) {
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STREAM_DRAW);

    const stride = 5 * 4; // 5 floats: x,y,r,g,b
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(aColorLoc);
    gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, stride, 2*4);

    gl.uniformMatrix3fv(uTransformLoc, false, transform);
    gl.drawArrays(mode, 0, vertices.length / 5);
  }

  // ---------- build geometric shapes in normalized coords ----------
  // We'll design the cat in local coordinates centered roughly at (0,0),
  // where the visible area maps to clip space directly (we'll scale to fit).

  // helper to create a triangle fan approximating an ellipse/circle
  function ellipseFan(cx, cy, rx, ry, color, segments=24) {
    const arr = [];
    arr.push(cx, cy, color[0], color[1], color[2]); // center
    for (let i=0;i<=segments;i++){
      const a = i / segments * Math.PI * 2;
      arr.push(cx + Math.cos(a) * rx, cy + Math.sin(a) * ry, color[0], color[1], color[2]);
    }
    return new Float32Array(arr);
  }

  // simple triangle (3 verts)
  function tri(x1,y1, x2,y2, x3,y3, color) {
    return new Float32Array([
      x1,y1, color[0],color[1],color[2],
      x2,y2, color[0],color[1],color[2],
      x3,y3, color[0],color[1],color[2]
    ]);
  }

  // rectangle as two triangles
  function rect(x,y,w,h,color) {
    return new Float32Array([
      x,   y,    color[0],color[1],color[2],
      x+w, y,    color[0],color[1],color[2],
      x,   y+h,  color[0],color[1],color[2],

      x+w, y,    color[0],color[1],color[2],
      x+w, y+h,  color[0],color[1],color[2],
      x,   y+h,  color[0],color[1],color[2]
    ]);
  }

  // ---------- cat parts definitions ----------
  // We'll design the cat in a local coordinate space where approx body fits inside [-0.5..0.5] box.
  const bodyColor = [1.0, 0.84, 0.6]; // warm cream
  const stripeColor = [0.9, 0.75, 0.5];
  const strokeColor = [0.42, 0.31, 0.24]; // darker for ears/nose if needed
  const eyeColor = [0.08, 0.07, 0.06];

  // body: ellipse center (0.0, -0.05)
  const bodyVerts = ellipseFan(0.0, -0.05, 0.33, 0.22, bodyColor, 28);

  // head: ellipse centered (0.0, 0.25)
  const headVerts = ellipseFan(0.0, 0.25, 0.18, 0.16, bodyColor, 28);

  // left ear triangle (relative to head center)
  const leftEar = tri(-0.08, 0.34, -0.18, 0.46, -0.02, 0.40, bodyColor);
  const rightEar = tri(0.08, 0.34, 0.18, 0.46, 0.02, 0.40, bodyColor);

  // eyes: small rects/triangles
  const leftEye = rect(-0.06, 0.18, 0.03, 0.02, eyeColor);
  const rightEye = rect(0.03, 0.18, 0.03, 0.02, eyeColor);

  // nose: small triangle
  const nose = tri(-0.01, 0.14, 0.02, 0.14, 0.005, 0.12, [0.88, 0.4, 0.43]);

  // mouth: two tiny triangles for cheeks (stylized)
  const mouthL = tri(-0.01, 0.12, -0.03, 0.10, 0.005, 0.11, strokeColor);
  const mouthR = tri(0.01, 0.12, 0.03, 0.10, -0.005, 0.11, strokeColor);

  // subtle stripes on body as small triangles
  const stripe1 = tri(-0.05, -0.02, 0.02, -0.06, 0.10, -0.01, stripeColor);
  const stripe2 = tri(-0.12, 0.00, -0.02, -0.04, 0.06, -0.02, stripeColor);

  // tail: we'll draw a rectangle and rotate around a pivot near body right-back.
  // tail rectangle coordinates (we'll position such that pivot is at (0.33, -0.02))
  // tail rect anchored so pivot is near left-top of rect; create at (0.33, -0.02) with local coords.
  const tailW = 0.18, tailH = 0.04;
  // We'll draw tail in its own local space at (0,0) and apply transform to position and rotate.
  const tailRectLocal = rect(0, -tailH/2, tailW, tailH, [0.42,0.31,0.24]); // dark tail

  // To draw tail, we transform: translate(pivot) * rotate(angle) * translate(-pivotLocal)
  // pivotLocal chosen at (0, -tailH/2) so rotation occurs at left-middle of rect.

  // ---------- drawing & animation ----------
  gl.clearColor(0,0,0,0); // transparent background
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  function resize() {
    // make drawing resolution match canvas pixel size
    const displayWidth  = canvas.clientWidth * devicePixelRatio;
    const displayHeight = canvas.clientHeight * devicePixelRatio;
    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
      canvas.width = displayWidth;
      canvas.height = displayHeight;
    }
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  resize();
  window.addEventListener('resize', resize);

  // Convert local coordinates we've been using (-~0.6..0.6) to clip space:
  // We'll scale everything by a model scale and then fit to clip space.
  const modelScale = 0.9; // adjust overall size inside canvas

  // Function to produce final transform: model -> clipspace
  // We'll map local coords directly into clip space with scale and aspect correction.
  function getBaseTransform() {
    // Our local coordinate system assumes square mapping; adjust for canvas aspect ratio
    const aspect = canvas.width / canvas.height;
    // want x scaled by modelScale/aspect to compensate for non-square pixels
    const sx = modelScale / aspect;
    const sy = modelScale;
    return Mat3.multiply(Mat3.scale(sx, sy), Mat3.identity());
  }

  // time & animation state
  let last = 0;
  let angle = 0;
  let tailPhase = 0;
  let hoverBoost = 1.0;

  // speed up wag on hover
  canvas.addEventListener('mouseenter', () => hoverBoost = 2.0);
  canvas.addEventListener('mouseleave', () => hoverBoost = 1.0);

  function render(t) {
    const dt = (t - last) * 0.001 || 0;
    last = t;
    angle += dt * 1.2; // bob phase
    tailPhase += dt * 6.0 * hoverBoost; // tail speed

    resize();
    gl.clear(gl.COLOR_BUFFER_BIT);

    // base transform to clip space
    const base = getBaseTransform();

    // Bob transform (gentle vertical motion)
    const bobY = Math.sin(angle) * 0.02;
    const bobTransform = Mat3.multiply(Mat3.translation(0, bobY), base);

    // --- draw body ---
    drawShape(bodyVerts, gl.TRIANGLE_FAN, bobTransform);

    // stripes
    drawShape(stripe1, gl.TRIANGLES, bobTransform);
    drawShape(stripe2, gl.TRIANGLES, bobTransform);

    // --- draw tail ---
    // Tail pivot in local coords (pivot near back-right of body)
    const pivotX = 0.33, pivotY = -0.02;
    // tail rotation angle (small oscillation)
    const tailAngle = Math.sin(tailPhase) * 0.45; // radians
    // build transform: translate(pivot) * rotate * translate(-pivotLocal) * base * bob
    // But we want bob to also affect tail, so compose as: translate(pivot) * rotate * translate(-0) * translate(pivot offset) * baseWithBob
    // easier: tail = translate(pivot) * rotate * translate(-pivotLocal) * bobTransform
    const t1 = Mat3.multiply(Mat3.translation(pivotX, pivotY), Mat3.rotation(tailAngle));
    const t2 = Mat3.multiply(t1, Mat3.translation(-0.0, 0.0)); // pivotLocal already considered
    const tailTransform = Mat3.multiply(t2, bobTransform);
    drawShape(tailRectLocal, gl.TRIANGLES, tailTransform);

    // --- draw head & ears & facial features ---
    drawShape(headVerts, gl.TRIANGLE_FAN, Mat3.multiply(Mat3.translation(0,0), bobTransform));
    drawShape(leftEar, gl.TRIANGLES, bobTransform);
    drawShape(rightEar, gl.TRIANGLES, bobTransform);

    drawShape(leftEye, gl.TRIANGLES, bobTransform);
    drawShape(rightEye, gl.TRIANGLES, bobTransform);
    drawShape(nose, gl.TRIANGLES, bobTransform);
    drawShape(mouthL, gl.TRIANGLES, bobTransform);
    drawShape(mouthR, gl.TRIANGLES, bobTransform);

    // done
    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
  
  </script>

</body>
</html>
